#!/bin/env ruby

DISPLAY_REGEX              = /([A-Z]+\d+)/
RESOLUTION_REGEX           = /([\d]+x[\d]+)/
POSITION_REGEX             = /\+([\d]+)\+([\d]+).+$/
CONNECTED_REGEX            = /\s+connected/
DISCONNECTED_ENABLED_REGEX = /disconnected\s+[^\(]/
CURRENT_SETTINGS_REGEX     = /#{CONNECTED_REGEX}\s+#{RESOLUTION_REGEX}/
LISTING_REGEX              = /^\s+#{RESOLUTION_REGEX}\s+.+$/

def run!
  if current_displays.length > 2
    Display.new(name: :LVDS1, resolution: :"1600x900").enable
    current_displays.reject { |d| d.name == :LVDS1 }.each(&:disable)
  else
    to_enable = cycled_displays
    to_disable = connected_displays.reject do |connected|
      to_enable.find { |cycled| cycled.name == connected.name }
    end

    (to_disable + disconnected_enabled_displays).each do |d|
      d.disable
      sleep 1
    end

    to_enable.each do |d|
      d.enable
      sleep 1
    end
  end

  apply_wallpaper
end

def cycled_displays
  combinations = all_possible_combinations
  which = combinations.index(current_displays)
  combinations[which.succ % combinations.length]
end

def all_possible_combinations
  1.upto(2).flat_map { |i| connected_displays.permutation(i).to_a }
           .map { |p| p.map(&:clone) }
           .each { |p| p.last.place(to: :right, of: p.first) if p.length > 1}
end

def apply_wallpaper
  `feh --bg-scale ~/.wallpapers/current_wallpaper`
end

def disconnected_enabled_displays
  disconnected_enabled.map { |sym| Display.new(name: sym) }
end

def connected_displays
  connected.map do |sym|
    Display.new(name: sym, resolution: resolutions[sym].first)
  end
end

def current_displays
  data = xrandr.grep(CURRENT_SETTINGS_REGEX)
  displays = data.map do |s|
    Display.new(name: parse_name(s),
                resolution: parse_resolution(s))
  end

  return displays if displays.length != 2

  positions = data.map { |s| parse_position(s) }
  place_right = positions.index(:right)
  relative_to = place_right.succ % 2

  displays[place_right].place(to: :right, of: displays[relative_to])
  displays.first.position ? displays.reverse : displays
end

def disconnected_enabled
  xrandr.grep(DISCONNECTED_ENABLED_REGEX).map { |s| parse_name(s) }
end

def connected
  xrandr.grep(CONNECTED_REGEX).map { |s| parse_name(s) }
end

def parse_name(s)
  s.match(DISPLAY_REGEX).captures.first.to_sym
end

def parse_resolution(s)
  s.match(RESOLUTION_REGEX).captures.first.to_sym
end

def parse_position(s)
  order(s.match(POSITION_REGEX).captures.first)
end

# I don't actually know what the parameter specifically means
# but I know I can use it to determine which screen
# is the extended one
def order(o)
  o.to_i.zero? ? :left : :right
end

def resolutions
  xrandr
    .map.with_index { |s, i| [parse_name(s), i] if s =~ CONNECTED_REGEX }
    .compact
    .reduce({}) do |resolutions, (name, i)|
      start = finish = i.succ
      finish += 1 while xrandr[finish].match(LISTING_REGEX)
      resolutions.tap do |rss|
        rss[name] = xrandr[start...finish].map { |s| parse_resolution(s) }
      end
    end
end

def xrandr
  @xrandr ||= `xrandr`.lines
end

class Display
  attr_reader :name, :resolution, :position, :relative_to

  def self.positions
    {left: :'left-of', right: :'right-of'}
  end

  def initialize(name:, resolution: nil)
    @name = name
    @resolution = resolution
  end

  def place(to:, of:)
    @position = to
    @relative_to = of
  end

  def disable
    puts off_command
    `#{off_command}`
  end

  def enable
    puts on_command
    `#{on_command}`

    return unless positioned?
    puts position_command
    `#{position_command}`
  end

  def ==(other)
    other.kind_of?(self.class) &&
      other.name == name &&
      other.resolution == resolution &&
      other.position == position &&
      other.relative_to == relative_to
  end

  alias_method :eql?, :==

  private

  def off_command
    "xrandr --output #{name} --off"
  end

  def on_command
    "xrandr --output #{name} --auto"
  end

  def position_command
    "xrandr --output #{name} --#{self.class.positions[position]} #{relative_to.name}"
  end

  def positioned?
    position && relative_to
  end
end

run!
